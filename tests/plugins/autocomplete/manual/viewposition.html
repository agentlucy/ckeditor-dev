<style>
	/* Swap margin with padding to prevent moving autocomplete panel outside editor. */
	body {
		margin-left: 0px;
		padding-left: 350px;
	}

	p.filler{
		height: 900px;
		border: 1px solid red;
	}
</style>

<h2>Classic editor</h2>
<div id="editor1" >
	<p>First line</p>
	<p class="filler">Filler</p>
	<p>Middle line</p>
	<p class="filler">Filler</p>
	<p>Last line</p>
</div>

<h2>Divarea editor</h2>
<div id="editor2" >
	<p>First line</p>
	<p class="filler">Filler</p>
	<p>Middle line</p>
	<p class="filler">Filler</p>
	<p>Last line</p>
</div>

<h2>Inline editor</h2>
<div id="editor3" contenteditable=true >
	<p>First line</p>
	<p class="filler">Filler</p>
	<p>Middle line</p>
	<p class="filler">Filler</p>
	<p>Last line</p>
</div>

<script>

initEditor( 'replace', 'editor1' );
initEditor( 'replace', 'editor2', 'divarea' );
initEditor( 'inline', 'editor3' );

function initEditor( creator, name, extraPlugins ) {
	var editor = CKEDITOR[ creator ]( name, {
		width: 600,
		extraAllowedContent: 'p(filler)',
		extraPlugins: extraPlugins && extraPlugins + ',textmatch' || 'textmatch',
		on: {
			instanceReady: function( evt ) {
				editor = evt.editor;

				new CKEDITOR.plugins.autocomplete( editor, getTextTestCallback(), dataCallback );
			}
		}
	} );
}

	function getTextTestCallback() {
		return function( range ) {
			return CKEDITOR.plugins.textMatch.match( range, matchCallback );
		};
	}

	function matchCallback( text, offset ) {
		var left = text.slice( 0, offset ),
			match = left.match( new RegExp( '@\\w*$' ) );

		if ( !match ) {
			return null;
		}

		return { start: match.index, end: offset };
	}

	function dataCallback( query, range, callback ) {
		var data = [
			{ id: 1, name: '@john' },
			{ id: 2, name: '@thomas' },
			{ id: 3, name: '@anna' },
			{ id: 4, name: '@cris' },
			{ id: 5, name: '@julia' }
		];

		callback(
			data.filter( function( item ) {
				return item.name.indexOf( query ) === 0;
			} )
		);
	}

</script>
